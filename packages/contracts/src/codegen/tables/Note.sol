// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

/* Autogenerated file. Do not edit manually. */

// Import store internals
import { IStore } from "@latticexyz/store/src/IStore.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";
import { StoreCore } from "@latticexyz/store/src/StoreCore.sol";
import { Bytes } from "@latticexyz/store/src/Bytes.sol";
import { Memory } from "@latticexyz/store/src/Memory.sol";
import { SliceLib } from "@latticexyz/store/src/Slice.sol";
import { EncodeArray } from "@latticexyz/store/src/tightcoder/EncodeArray.sol";
import { FieldLayout } from "@latticexyz/store/src/FieldLayout.sol";
import { Schema } from "@latticexyz/store/src/Schema.sol";
import { EncodedLengths, EncodedLengthsLib } from "@latticexyz/store/src/EncodedLengths.sol";
import { ResourceId } from "@latticexyz/store/src/ResourceId.sol";

struct NoteData {
  address owner;
  uint64 createdAt;
  uint64 updatedAt;
  address tipJar;
  uint64 boostUntil;
  uint256 totalTips;
  string title;
  string kicker;
  string content;
  string tags;
  string headerImageUrl;
}

library Note {
  // Hex below is the result of `WorldResourceIdLib.encode({ namespace: "rg_dd_0001", name: "Note", typeId: RESOURCE_TABLE });`
  ResourceId constant _tableId = ResourceId.wrap(0x746272675f64645f30303031000000004e6f7465000000000000000000000000);

  FieldLayout constant _fieldLayout =
    FieldLayout.wrap(0x0060060514080814082000000000000000000000000000000000000000000000);

  // Hex-encoded key schema of (bytes32)
  Schema constant _keySchema = Schema.wrap(0x002001005f000000000000000000000000000000000000000000000000000000);
  // Hex-encoded value schema of (address, uint64, uint64, address, uint64, uint256, string, string, string, string, string)
  Schema constant _valueSchema = Schema.wrap(0x0060060561070761071fc5c5c5c5c50000000000000000000000000000000000);

  /**
   * @notice Get the table's key field names.
   * @return keyNames An array of strings with the names of key fields.
   */
  function getKeyNames() internal pure returns (string[] memory keyNames) {
    keyNames = new string[](1);
    keyNames[0] = "noteId";
  }

  /**
   * @notice Get the table's value field names.
   * @return fieldNames An array of strings with the names of value fields.
   */
  function getFieldNames() internal pure returns (string[] memory fieldNames) {
    fieldNames = new string[](11);
    fieldNames[0] = "owner";
    fieldNames[1] = "createdAt";
    fieldNames[2] = "updatedAt";
    fieldNames[3] = "tipJar";
    fieldNames[4] = "boostUntil";
    fieldNames[5] = "totalTips";
    fieldNames[6] = "title";
    fieldNames[7] = "kicker";
    fieldNames[8] = "content";
    fieldNames[9] = "tags";
    fieldNames[10] = "headerImageUrl";
  }

  /**
   * @notice Register the table with its config.
   */
  function register() internal {
    StoreSwitch.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());
  }

  /**
   * @notice Register the table with its config.
   */
  function _register() internal {
    StoreCore.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());
  }

  /**
   * @notice Get owner.
   */
  function getOwner(bytes32 noteId) internal view returns (address owner) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);
    return (address(bytes20(_blob)));
  }

  /**
   * @notice Get owner.
   */
  function _getOwner(bytes32 noteId) internal view returns (address owner) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);
    return (address(bytes20(_blob)));
  }

  /**
   * @notice Set owner.
   */
  function setOwner(bytes32 noteId, address owner) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((owner)), _fieldLayout);
  }

  /**
   * @notice Set owner.
   */
  function _setOwner(bytes32 noteId, address owner) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((owner)), _fieldLayout);
  }

  /**
   * @notice Get createdAt.
   */
  function getCreatedAt(bytes32 noteId) internal view returns (uint64 createdAt) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 1, _fieldLayout);
    return (uint64(bytes8(_blob)));
  }

  /**
   * @notice Get createdAt.
   */
  function _getCreatedAt(bytes32 noteId) internal view returns (uint64 createdAt) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 1, _fieldLayout);
    return (uint64(bytes8(_blob)));
  }

  /**
   * @notice Set createdAt.
   */
  function setCreatedAt(bytes32 noteId, uint64 createdAt) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 1, abi.encodePacked((createdAt)), _fieldLayout);
  }

  /**
   * @notice Set createdAt.
   */
  function _setCreatedAt(bytes32 noteId, uint64 createdAt) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setStaticField(_tableId, _keyTuple, 1, abi.encodePacked((createdAt)), _fieldLayout);
  }

  /**
   * @notice Get updatedAt.
   */
  function getUpdatedAt(bytes32 noteId) internal view returns (uint64 updatedAt) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 2, _fieldLayout);
    return (uint64(bytes8(_blob)));
  }

  /**
   * @notice Get updatedAt.
   */
  function _getUpdatedAt(bytes32 noteId) internal view returns (uint64 updatedAt) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 2, _fieldLayout);
    return (uint64(bytes8(_blob)));
  }

  /**
   * @notice Set updatedAt.
   */
  function setUpdatedAt(bytes32 noteId, uint64 updatedAt) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 2, abi.encodePacked((updatedAt)), _fieldLayout);
  }

  /**
   * @notice Set updatedAt.
   */
  function _setUpdatedAt(bytes32 noteId, uint64 updatedAt) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setStaticField(_tableId, _keyTuple, 2, abi.encodePacked((updatedAt)), _fieldLayout);
  }

  /**
   * @notice Get tipJar.
   */
  function getTipJar(bytes32 noteId) internal view returns (address tipJar) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 3, _fieldLayout);
    return (address(bytes20(_blob)));
  }

  /**
   * @notice Get tipJar.
   */
  function _getTipJar(bytes32 noteId) internal view returns (address tipJar) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 3, _fieldLayout);
    return (address(bytes20(_blob)));
  }

  /**
   * @notice Set tipJar.
   */
  function setTipJar(bytes32 noteId, address tipJar) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 3, abi.encodePacked((tipJar)), _fieldLayout);
  }

  /**
   * @notice Set tipJar.
   */
  function _setTipJar(bytes32 noteId, address tipJar) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setStaticField(_tableId, _keyTuple, 3, abi.encodePacked((tipJar)), _fieldLayout);
  }

  /**
   * @notice Get boostUntil.
   */
  function getBoostUntil(bytes32 noteId) internal view returns (uint64 boostUntil) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 4, _fieldLayout);
    return (uint64(bytes8(_blob)));
  }

  /**
   * @notice Get boostUntil.
   */
  function _getBoostUntil(bytes32 noteId) internal view returns (uint64 boostUntil) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 4, _fieldLayout);
    return (uint64(bytes8(_blob)));
  }

  /**
   * @notice Set boostUntil.
   */
  function setBoostUntil(bytes32 noteId, uint64 boostUntil) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 4, abi.encodePacked((boostUntil)), _fieldLayout);
  }

  /**
   * @notice Set boostUntil.
   */
  function _setBoostUntil(bytes32 noteId, uint64 boostUntil) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setStaticField(_tableId, _keyTuple, 4, abi.encodePacked((boostUntil)), _fieldLayout);
  }

  /**
   * @notice Get totalTips.
   */
  function getTotalTips(bytes32 noteId) internal view returns (uint256 totalTips) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 5, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get totalTips.
   */
  function _getTotalTips(bytes32 noteId) internal view returns (uint256 totalTips) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 5, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set totalTips.
   */
  function setTotalTips(bytes32 noteId, uint256 totalTips) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 5, abi.encodePacked((totalTips)), _fieldLayout);
  }

  /**
   * @notice Set totalTips.
   */
  function _setTotalTips(bytes32 noteId, uint256 totalTips) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setStaticField(_tableId, _keyTuple, 5, abi.encodePacked((totalTips)), _fieldLayout);
  }

  /**
   * @notice Get title.
   */
  function getTitle(bytes32 noteId) internal view returns (string memory title) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);
    return (string(_blob));
  }

  /**
   * @notice Get title.
   */
  function _getTitle(bytes32 noteId) internal view returns (string memory title) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);
    return (string(_blob));
  }

  /**
   * @notice Set title.
   */
  function setTitle(bytes32 noteId, string memory title) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, bytes((title)));
  }

  /**
   * @notice Set title.
   */
  function _setTitle(bytes32 noteId, string memory title) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setDynamicField(_tableId, _keyTuple, 0, bytes((title)));
  }

  /**
   * @notice Get the length of title.
   */
  function lengthTitle(bytes32 noteId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);
    unchecked {
      return _byteLength / 1;
    }
  }

  /**
   * @notice Get the length of title.
   */
  function _lengthTitle(bytes32 noteId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);
    unchecked {
      return _byteLength / 1;
    }
  }

  /**
   * @notice Get an item of title.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemTitle(bytes32 noteId, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 1, (_index + 1) * 1);
      return (string(_blob));
    }
  }

  /**
   * @notice Get an item of title.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemTitle(bytes32 noteId, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 1, (_index + 1) * 1);
      return (string(_blob));
    }
  }

  /**
   * @notice Push a slice to title.
   */
  function pushTitle(bytes32 noteId, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 0, bytes((_slice)));
  }

  /**
   * @notice Push a slice to title.
   */
  function _pushTitle(bytes32 noteId, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.pushToDynamicField(_tableId, _keyTuple, 0, bytes((_slice)));
  }

  /**
   * @notice Pop a slice from title.
   */
  function popTitle(bytes32 noteId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 0, 1);
  }

  /**
   * @notice Pop a slice from title.
   */
  function _popTitle(bytes32 noteId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.popFromDynamicField(_tableId, _keyTuple, 0, 1);
  }

  /**
   * @notice Update a slice of title at `_index`.
   */
  function updateTitle(bytes32 noteId, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _encoded = bytes((_slice));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 1), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update a slice of title at `_index`.
   */
  function _updateTitle(bytes32 noteId, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _encoded = bytes((_slice));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 1), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get kicker.
   */
  function getKicker(bytes32 noteId) internal view returns (string memory kicker) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 1);
    return (string(_blob));
  }

  /**
   * @notice Get kicker.
   */
  function _getKicker(bytes32 noteId) internal view returns (string memory kicker) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 1);
    return (string(_blob));
  }

  /**
   * @notice Set kicker.
   */
  function setKicker(bytes32 noteId, string memory kicker) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setDynamicField(_tableId, _keyTuple, 1, bytes((kicker)));
  }

  /**
   * @notice Set kicker.
   */
  function _setKicker(bytes32 noteId, string memory kicker) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setDynamicField(_tableId, _keyTuple, 1, bytes((kicker)));
  }

  /**
   * @notice Get the length of kicker.
   */
  function lengthKicker(bytes32 noteId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 1);
    unchecked {
      return _byteLength / 1;
    }
  }

  /**
   * @notice Get the length of kicker.
   */
  function _lengthKicker(bytes32 noteId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 1);
    unchecked {
      return _byteLength / 1;
    }
  }

  /**
   * @notice Get an item of kicker.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemKicker(bytes32 noteId, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 1, _index * 1, (_index + 1) * 1);
      return (string(_blob));
    }
  }

  /**
   * @notice Get an item of kicker.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemKicker(bytes32 noteId, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 1, _index * 1, (_index + 1) * 1);
      return (string(_blob));
    }
  }

  /**
   * @notice Push a slice to kicker.
   */
  function pushKicker(bytes32 noteId, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 1, bytes((_slice)));
  }

  /**
   * @notice Push a slice to kicker.
   */
  function _pushKicker(bytes32 noteId, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.pushToDynamicField(_tableId, _keyTuple, 1, bytes((_slice)));
  }

  /**
   * @notice Pop a slice from kicker.
   */
  function popKicker(bytes32 noteId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 1, 1);
  }

  /**
   * @notice Pop a slice from kicker.
   */
  function _popKicker(bytes32 noteId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.popFromDynamicField(_tableId, _keyTuple, 1, 1);
  }

  /**
   * @notice Update a slice of kicker at `_index`.
   */
  function updateKicker(bytes32 noteId, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _encoded = bytes((_slice));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 1, uint40(_index * 1), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update a slice of kicker at `_index`.
   */
  function _updateKicker(bytes32 noteId, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _encoded = bytes((_slice));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 1, uint40(_index * 1), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get content.
   */
  function getContent(bytes32 noteId) internal view returns (string memory content) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 2);
    return (string(_blob));
  }

  /**
   * @notice Get content.
   */
  function _getContent(bytes32 noteId) internal view returns (string memory content) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 2);
    return (string(_blob));
  }

  /**
   * @notice Set content.
   */
  function setContent(bytes32 noteId, string memory content) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setDynamicField(_tableId, _keyTuple, 2, bytes((content)));
  }

  /**
   * @notice Set content.
   */
  function _setContent(bytes32 noteId, string memory content) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setDynamicField(_tableId, _keyTuple, 2, bytes((content)));
  }

  /**
   * @notice Get the length of content.
   */
  function lengthContent(bytes32 noteId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 2);
    unchecked {
      return _byteLength / 1;
    }
  }

  /**
   * @notice Get the length of content.
   */
  function _lengthContent(bytes32 noteId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 2);
    unchecked {
      return _byteLength / 1;
    }
  }

  /**
   * @notice Get an item of content.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemContent(bytes32 noteId, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 2, _index * 1, (_index + 1) * 1);
      return (string(_blob));
    }
  }

  /**
   * @notice Get an item of content.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemContent(bytes32 noteId, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 2, _index * 1, (_index + 1) * 1);
      return (string(_blob));
    }
  }

  /**
   * @notice Push a slice to content.
   */
  function pushContent(bytes32 noteId, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 2, bytes((_slice)));
  }

  /**
   * @notice Push a slice to content.
   */
  function _pushContent(bytes32 noteId, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.pushToDynamicField(_tableId, _keyTuple, 2, bytes((_slice)));
  }

  /**
   * @notice Pop a slice from content.
   */
  function popContent(bytes32 noteId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 2, 1);
  }

  /**
   * @notice Pop a slice from content.
   */
  function _popContent(bytes32 noteId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.popFromDynamicField(_tableId, _keyTuple, 2, 1);
  }

  /**
   * @notice Update a slice of content at `_index`.
   */
  function updateContent(bytes32 noteId, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _encoded = bytes((_slice));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 2, uint40(_index * 1), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update a slice of content at `_index`.
   */
  function _updateContent(bytes32 noteId, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _encoded = bytes((_slice));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 2, uint40(_index * 1), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get tags.
   */
  function getTags(bytes32 noteId) internal view returns (string memory tags) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 3);
    return (string(_blob));
  }

  /**
   * @notice Get tags.
   */
  function _getTags(bytes32 noteId) internal view returns (string memory tags) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 3);
    return (string(_blob));
  }

  /**
   * @notice Set tags.
   */
  function setTags(bytes32 noteId, string memory tags) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setDynamicField(_tableId, _keyTuple, 3, bytes((tags)));
  }

  /**
   * @notice Set tags.
   */
  function _setTags(bytes32 noteId, string memory tags) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setDynamicField(_tableId, _keyTuple, 3, bytes((tags)));
  }

  /**
   * @notice Get the length of tags.
   */
  function lengthTags(bytes32 noteId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 3);
    unchecked {
      return _byteLength / 1;
    }
  }

  /**
   * @notice Get the length of tags.
   */
  function _lengthTags(bytes32 noteId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 3);
    unchecked {
      return _byteLength / 1;
    }
  }

  /**
   * @notice Get an item of tags.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemTags(bytes32 noteId, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 3, _index * 1, (_index + 1) * 1);
      return (string(_blob));
    }
  }

  /**
   * @notice Get an item of tags.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemTags(bytes32 noteId, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 3, _index * 1, (_index + 1) * 1);
      return (string(_blob));
    }
  }

  /**
   * @notice Push a slice to tags.
   */
  function pushTags(bytes32 noteId, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 3, bytes((_slice)));
  }

  /**
   * @notice Push a slice to tags.
   */
  function _pushTags(bytes32 noteId, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.pushToDynamicField(_tableId, _keyTuple, 3, bytes((_slice)));
  }

  /**
   * @notice Pop a slice from tags.
   */
  function popTags(bytes32 noteId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 3, 1);
  }

  /**
   * @notice Pop a slice from tags.
   */
  function _popTags(bytes32 noteId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.popFromDynamicField(_tableId, _keyTuple, 3, 1);
  }

  /**
   * @notice Update a slice of tags at `_index`.
   */
  function updateTags(bytes32 noteId, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _encoded = bytes((_slice));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 3, uint40(_index * 1), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update a slice of tags at `_index`.
   */
  function _updateTags(bytes32 noteId, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _encoded = bytes((_slice));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 3, uint40(_index * 1), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get headerImageUrl.
   */
  function getHeaderImageUrl(bytes32 noteId) internal view returns (string memory headerImageUrl) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 4);
    return (string(_blob));
  }

  /**
   * @notice Get headerImageUrl.
   */
  function _getHeaderImageUrl(bytes32 noteId) internal view returns (string memory headerImageUrl) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 4);
    return (string(_blob));
  }

  /**
   * @notice Set headerImageUrl.
   */
  function setHeaderImageUrl(bytes32 noteId, string memory headerImageUrl) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setDynamicField(_tableId, _keyTuple, 4, bytes((headerImageUrl)));
  }

  /**
   * @notice Set headerImageUrl.
   */
  function _setHeaderImageUrl(bytes32 noteId, string memory headerImageUrl) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setDynamicField(_tableId, _keyTuple, 4, bytes((headerImageUrl)));
  }

  /**
   * @notice Get the length of headerImageUrl.
   */
  function lengthHeaderImageUrl(bytes32 noteId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 4);
    unchecked {
      return _byteLength / 1;
    }
  }

  /**
   * @notice Get the length of headerImageUrl.
   */
  function _lengthHeaderImageUrl(bytes32 noteId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 4);
    unchecked {
      return _byteLength / 1;
    }
  }

  /**
   * @notice Get an item of headerImageUrl.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemHeaderImageUrl(bytes32 noteId, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 4, _index * 1, (_index + 1) * 1);
      return (string(_blob));
    }
  }

  /**
   * @notice Get an item of headerImageUrl.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemHeaderImageUrl(bytes32 noteId, uint256 _index) internal view returns (string memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 4, _index * 1, (_index + 1) * 1);
      return (string(_blob));
    }
  }

  /**
   * @notice Push a slice to headerImageUrl.
   */
  function pushHeaderImageUrl(bytes32 noteId, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 4, bytes((_slice)));
  }

  /**
   * @notice Push a slice to headerImageUrl.
   */
  function _pushHeaderImageUrl(bytes32 noteId, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.pushToDynamicField(_tableId, _keyTuple, 4, bytes((_slice)));
  }

  /**
   * @notice Pop a slice from headerImageUrl.
   */
  function popHeaderImageUrl(bytes32 noteId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 4, 1);
  }

  /**
   * @notice Pop a slice from headerImageUrl.
   */
  function _popHeaderImageUrl(bytes32 noteId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.popFromDynamicField(_tableId, _keyTuple, 4, 1);
  }

  /**
   * @notice Update a slice of headerImageUrl at `_index`.
   */
  function updateHeaderImageUrl(bytes32 noteId, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _encoded = bytes((_slice));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 4, uint40(_index * 1), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update a slice of headerImageUrl at `_index`.
   */
  function _updateHeaderImageUrl(bytes32 noteId, uint256 _index, string memory _slice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    unchecked {
      bytes memory _encoded = bytes((_slice));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 4, uint40(_index * 1), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get the full data.
   */
  function get(bytes32 noteId) internal view returns (NoteData memory _table) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    (bytes memory _staticData, EncodedLengths _encodedLengths, bytes memory _dynamicData) = StoreSwitch.getRecord(
      _tableId,
      _keyTuple,
      _fieldLayout
    );
    return decode(_staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Get the full data.
   */
  function _get(bytes32 noteId) internal view returns (NoteData memory _table) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    (bytes memory _staticData, EncodedLengths _encodedLengths, bytes memory _dynamicData) = StoreCore.getRecord(
      _tableId,
      _keyTuple,
      _fieldLayout
    );
    return decode(_staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Set the full data using individual values.
   */
  function set(
    bytes32 noteId,
    address owner,
    uint64 createdAt,
    uint64 updatedAt,
    address tipJar,
    uint64 boostUntil,
    uint256 totalTips,
    string memory title,
    string memory kicker,
    string memory content,
    string memory tags,
    string memory headerImageUrl
  ) internal {
    bytes memory _staticData = encodeStatic(owner, createdAt, updatedAt, tipJar, boostUntil, totalTips);

    EncodedLengths _encodedLengths = encodeLengths(title, kicker, content, tags, headerImageUrl);
    bytes memory _dynamicData = encodeDynamic(title, kicker, content, tags, headerImageUrl);

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Set the full data using individual values.
   */
  function _set(
    bytes32 noteId,
    address owner,
    uint64 createdAt,
    uint64 updatedAt,
    address tipJar,
    uint64 boostUntil,
    uint256 totalTips,
    string memory title,
    string memory kicker,
    string memory content,
    string memory tags,
    string memory headerImageUrl
  ) internal {
    bytes memory _staticData = encodeStatic(owner, createdAt, updatedAt, tipJar, boostUntil, totalTips);

    EncodedLengths _encodedLengths = encodeLengths(title, kicker, content, tags, headerImageUrl);
    bytes memory _dynamicData = encodeDynamic(title, kicker, content, tags, headerImageUrl);

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData, _fieldLayout);
  }

  /**
   * @notice Set the full data using the data struct.
   */
  function set(bytes32 noteId, NoteData memory _table) internal {
    bytes memory _staticData = encodeStatic(
      _table.owner,
      _table.createdAt,
      _table.updatedAt,
      _table.tipJar,
      _table.boostUntil,
      _table.totalTips
    );

    EncodedLengths _encodedLengths = encodeLengths(
      _table.title,
      _table.kicker,
      _table.content,
      _table.tags,
      _table.headerImageUrl
    );
    bytes memory _dynamicData = encodeDynamic(
      _table.title,
      _table.kicker,
      _table.content,
      _table.tags,
      _table.headerImageUrl
    );

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Set the full data using the data struct.
   */
  function _set(bytes32 noteId, NoteData memory _table) internal {
    bytes memory _staticData = encodeStatic(
      _table.owner,
      _table.createdAt,
      _table.updatedAt,
      _table.tipJar,
      _table.boostUntil,
      _table.totalTips
    );

    EncodedLengths _encodedLengths = encodeLengths(
      _table.title,
      _table.kicker,
      _table.content,
      _table.tags,
      _table.headerImageUrl
    );
    bytes memory _dynamicData = encodeDynamic(
      _table.title,
      _table.kicker,
      _table.content,
      _table.tags,
      _table.headerImageUrl
    );

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData, _fieldLayout);
  }

  /**
   * @notice Decode the tightly packed blob of static data using this table's field layout.
   */
  function decodeStatic(
    bytes memory _blob
  )
    internal
    pure
    returns (address owner, uint64 createdAt, uint64 updatedAt, address tipJar, uint64 boostUntil, uint256 totalTips)
  {
    owner = (address(Bytes.getBytes20(_blob, 0)));

    createdAt = (uint64(Bytes.getBytes8(_blob, 20)));

    updatedAt = (uint64(Bytes.getBytes8(_blob, 28)));

    tipJar = (address(Bytes.getBytes20(_blob, 36)));

    boostUntil = (uint64(Bytes.getBytes8(_blob, 56)));

    totalTips = (uint256(Bytes.getBytes32(_blob, 64)));
  }

  /**
   * @notice Decode the tightly packed blob of dynamic data using the encoded lengths.
   */
  function decodeDynamic(
    EncodedLengths _encodedLengths,
    bytes memory _blob
  )
    internal
    pure
    returns (
      string memory title,
      string memory kicker,
      string memory content,
      string memory tags,
      string memory headerImageUrl
    )
  {
    uint256 _start;
    uint256 _end;
    unchecked {
      _end = _encodedLengths.atIndex(0);
    }
    title = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));

    _start = _end;
    unchecked {
      _end += _encodedLengths.atIndex(1);
    }
    kicker = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));

    _start = _end;
    unchecked {
      _end += _encodedLengths.atIndex(2);
    }
    content = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));

    _start = _end;
    unchecked {
      _end += _encodedLengths.atIndex(3);
    }
    tags = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));

    _start = _end;
    unchecked {
      _end += _encodedLengths.atIndex(4);
    }
    headerImageUrl = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));
  }

  /**
   * @notice Decode the tightly packed blobs using this table's field layout.
   * @param _staticData Tightly packed static fields.
   * @param _encodedLengths Encoded lengths of dynamic fields.
   * @param _dynamicData Tightly packed dynamic fields.
   */
  function decode(
    bytes memory _staticData,
    EncodedLengths _encodedLengths,
    bytes memory _dynamicData
  ) internal pure returns (NoteData memory _table) {
    (
      _table.owner,
      _table.createdAt,
      _table.updatedAt,
      _table.tipJar,
      _table.boostUntil,
      _table.totalTips
    ) = decodeStatic(_staticData);

    (_table.title, _table.kicker, _table.content, _table.tags, _table.headerImageUrl) = decodeDynamic(
      _encodedLengths,
      _dynamicData
    );
  }

  /**
   * @notice Delete all data for given keys.
   */
  function deleteRecord(bytes32 noteId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreSwitch.deleteRecord(_tableId, _keyTuple);
  }

  /**
   * @notice Delete all data for given keys.
   */
  function _deleteRecord(bytes32 noteId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);
  }

  /**
   * @notice Tightly pack static (fixed length) data using this table's schema.
   * @return The static data, encoded into a sequence of bytes.
   */
  function encodeStatic(
    address owner,
    uint64 createdAt,
    uint64 updatedAt,
    address tipJar,
    uint64 boostUntil,
    uint256 totalTips
  ) internal pure returns (bytes memory) {
    return abi.encodePacked(owner, createdAt, updatedAt, tipJar, boostUntil, totalTips);
  }

  /**
   * @notice Tightly pack dynamic data lengths using this table's schema.
   * @return _encodedLengths The lengths of the dynamic fields (packed into a single bytes32 value).
   */
  function encodeLengths(
    string memory title,
    string memory kicker,
    string memory content,
    string memory tags,
    string memory headerImageUrl
  ) internal pure returns (EncodedLengths _encodedLengths) {
    // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits
    unchecked {
      _encodedLengths = EncodedLengthsLib.pack(
        bytes(title).length,
        bytes(kicker).length,
        bytes(content).length,
        bytes(tags).length,
        bytes(headerImageUrl).length
      );
    }
  }

  /**
   * @notice Tightly pack dynamic (variable length) data using this table's schema.
   * @return The dynamic data, encoded into a sequence of bytes.
   */
  function encodeDynamic(
    string memory title,
    string memory kicker,
    string memory content,
    string memory tags,
    string memory headerImageUrl
  ) internal pure returns (bytes memory) {
    return abi.encodePacked(bytes((title)), bytes((kicker)), bytes((content)), bytes((tags)), bytes((headerImageUrl)));
  }

  /**
   * @notice Encode all of a record's fields.
   * @return The static (fixed length) data, encoded into a sequence of bytes.
   * @return The lengths of the dynamic fields (packed into a single bytes32 value).
   * @return The dynamic (variable length) data, encoded into a sequence of bytes.
   */
  function encode(
    address owner,
    uint64 createdAt,
    uint64 updatedAt,
    address tipJar,
    uint64 boostUntil,
    uint256 totalTips,
    string memory title,
    string memory kicker,
    string memory content,
    string memory tags,
    string memory headerImageUrl
  ) internal pure returns (bytes memory, EncodedLengths, bytes memory) {
    bytes memory _staticData = encodeStatic(owner, createdAt, updatedAt, tipJar, boostUntil, totalTips);

    EncodedLengths _encodedLengths = encodeLengths(title, kicker, content, tags, headerImageUrl);
    bytes memory _dynamicData = encodeDynamic(title, kicker, content, tags, headerImageUrl);

    return (_staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Encode keys as a bytes32 array using this table's field layout.
   */
  function encodeKeyTuple(bytes32 noteId) internal pure returns (bytes32[] memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = noteId;

    return _keyTuple;
  }
}
